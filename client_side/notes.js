// هادي ملاحظات بنستخلصها من كل مشروع 
// 1--- bootstrap gutters  اهم ملاحظة الا وهي ال 
// -- بين الكولومس  gap هلقيت كيف بدي تخلي مسافة بين الكاردس او كيف بدك تعمل 

// بتنضاف للكولومس يعني شوف صديقي العزيز  padding الجاب هما عبارة عن 

<div className='row gx-3'>


    {/* هان هتلاقي معمول للكول شوية بادينج */}
    <div className='col-4' > 
        {/* كونتنت الكولوم بيكون في الداخل يا وحش  */}
        <div className='card' style={{backgroundColor:"red" , height:"100px" }}>
        </div>
    </div>
    {/* ممنوع يكون اي كلاس جنب الكولم هان بالمرة ممنوع */}
    <div className='col-8' >
        <div className='card ' style={{backgroundColor:"black" , height:"100px"}}>
        </div>
    </div>




</div>


// row 
//  ----- col-4 inside it card 
//  ----- col-8 inside it card 

// col-4.card.products_card (false) the gutter will not appearing
// col-4 >> card.products_card (True) the gutter will apear



// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================



// توضحيات :
// export const name = createAsyncThunk('type or any name you want ', async func) 

// async (argument , thunkAPI)  
// argument >> is the payload you pass to the action creator
// thunkAPI >> is an object that contains some useful methods :
//          1. dispatch >> to dispatch another actions form thunk
//          2. getState >> to get the current state of the store
//          3. rejectWithValue >> to reject the action with a value
//          4. signal , extra >> advanced usage


// async () =>{
//     try{

//     }catch(error){
//         return thunkAPI.rejectWithValue(error.response.data)
//     }

// }

// =============================================================
// =============================================================
// =============================================================
// 1-
// sync متزامن يعني بينفذ الكود سطر ورا سطر ولا ينتقل الى سطر اخر حتى انتهاء السابق
// async جاهز async فيه settimeout غير متزامن يعني يعني يخلي الكود يشتغل والكود الي بياخد وقت يخليه يشتغل في الخلفية  ومن اشهر استخدامتها

// 2- 
// promises  :  fullfiled  rejected , pending  هو عبارة عن وعد وبيعتمد على تتبع عملية غير متزامنة ويمكن ان تكون حالتها 

    var loading = false 
    const myPromise = new Promise((resolve, reject) => {
        setTimeout(() => {
            
            // pending 
                setloading(true)

                
            resolve("تم بنجاح");
            // أو: reject("صار خطأ");
        }, 2000);
    });
    
    // fullfilled
    myPromise.then((result) => { 
        setloading(false)

            console.log(result); // "تم بنجاح"
        })
        // rejected
        .catch((error) => {
        setloading(false)

          console.log(error); // "صار خطأ"
        });


// 3-
// ======= async - await  هادا نظام قديم هلقيت صار استعمال افضل باستعمال 
//  rejected , fullfilled  >> باستعمال Try-catch
// loading >> لعب على الفانكشن
async function getProducts() {  // async : يعني فانكشن غير متزامنة وبدي اديرها باستخدام بروميس لكن بنظام جديد 
    setloading(true)
  try {  
    const response = await axios.get('/api/products');  // await : هتشتغل اثناء تنفيذ الريكوست  async func حتى انتهاء الفيتش لكن الاسطر الي خارج ال async يعني اصبر ما تنزلش في الكود داخل فانكشن ال
    console.log(response.data); // قبله await ويوجد  async and in try مش هيتنفذ الا بعد انتهاء الفانكشن لانه داخل فانكشن 
  } catch (error) {
    console.log(error);
  }
}
console.log("test")  // هيتنفذ اثناء الريكوست ويتنفذ الي بعديها كمان

// 4- مصطلحات مهمة وتوضيح بعض الامور

// https://www.youtube.com/watch?v=eiC58R16hb8




// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// ==============================================================================
// Cors - cross orgin resource sharing
// هي عبارة عن سياسة امان في المتصفح تمنع المواقع من الوصول الى موارد مواقع اخرى

// فش كروس لانك على نفس السيرفر بتبعت وبتستقبل من نفس الدومين  cross orgin لو عملت ريكوست على الباك اند من نفس الدومين يعني لوكنت رابط المشروعين على نفس الدومين مش هيعمل اي مشكلة لانه نفس الريسورس ومش هيعتبر 
// فعشان هيك احنا بنستخدم هادي الحماية عشان نحدد المواقع الي بتقدر تبعت ريكوستات على السيرفر  cross orgin لكن لو كان عندك موقع فرونت شغال على دومين معين وموقع باك اند شغال على دومين اخر بيصير الكروس 
// طيب ايش الهدف منها ؟؟ 
// في مواقع بتدخلها مثلا بتضغط زر ملهوش اي علاقة بايشي معين  الموقع بيخليك تعمل ريكوست على موقع مشهور زي البنك او حاجة زي كدا
// من خلال انها تخلي فقط دومين الفرونت الخاص بالموقع الي يعمل ريكوست cors فحماية البنك بتحل هادي المشكلة بال

// ✅ كيف يحل CORS المشكلة؟
// المتصفح يرسل طلب OPTIONS (preflight) قبل تنفيذ الطلب الفعلي.
// إذا رد الباكند بهيدر يحدد أن هذا الدومين مسموح له → يتم تنفيذ الطلب.
// إذا لم يرد أو لم يسمح → يتم حظر الطلب من المتصفح مباشرة.


// INSTALLED_APPS = [
//     'corsheaders',
//     ...
// ]

// MIDDLEWARE = [
//     'corsheaders.middleware.CorsMiddleware',
//     'django.middleware.common.CommonMiddleware',
//     ...
// ]

// CORS_ALLOWED_ORIGINS = [
//     "http://localhost:3000",
// ]



// ====================================================
// ====================================================
// ====================================================
// ====================================================

// لماذا دائما يحصل conflict بين useselector from redux and useeffec ? 


// قال ChatGPT:
// سؤال ذكي جدًا يا أحمد 👏
// خليني أشرح لك ليش أحيانًا يصير "تعارض" (أو مشاكل سلوك مش متوقع) بين useSelector و useEffect في React + Redux Toolkit:

// 🧠 أولًا: نفهم كيف يشتغل كل واحد
// ✅ useSelector:
// يُستخدم لقراءة قيمة من الـ Redux store.

// أي تغيير في القيمة في الـ store → يجعل الكومبوننت يعيد render.

// هو reactive: يعني يراقب التغير تلقائيًا.

// ✅ useEffect:
// يُستخدم لتشغيل كود بعد كل render حسب تغيّرات محددة (dependencies).

// 😵‍💫 أين يحصل التعارض أو المشاكل؟
// 1. تكرار التنفيذ بشكل غير متوقع
// مثال:

// jsx
// نسخ
// تحرير
// const user = useSelector((state) => state.auth.user);

// useEffect(() => {
//   dispatch(fetchUser());
// }, [user]);
// ❌ هنا يحصل خطأ منطقي:

// fetchUser() يقوم بتحديث user في الـ Redux.

// هذا يجعل user يتغير ➤ يعيد تنفيذ useEffect.

// يعيد dispatch(fetchUser()) ➤ ويعيد user التحديث...

// 🔁 🔁 🔁 حلقة لا نهائية أو تنفيذ متكرر.

// ✅ الحل:
// ضع trigger منفصل أو استدعِه مرة وحدة:

// jsx
// نسخ
// تحرير
// useEffect(() => {
//   dispatch(fetchUser());
// }, []); // ✅ فقط عند أول مرة
// 2. تأخر قيمة useSelector في أول مرة
// أحيانًا تكون قيمة useSelector:

// js
// نسخ
// تحرير
// undefined أو null أو {}
// وهذا طبيعي، لأن البيانات لم تصل بعد. فتكتب useEffect هكذا:

// jsx
// نسخ
// تحرير
// useEffect(() => {
//   if (!user) {
//     dispatch(fetchUser());
//   }
// }, [user]);
// لكن:

// أول مرة user = null → ينفذ dispatch(fetchUser())

// ثم user يصير فيه بيانات → فيصير useEffect يتنفذ مرة ثانية

// إذا كان الكود فيه dispatchات داخلية، ممكن يصير تعارض أو تحميل زائد

// 🎯 خلاصة السبب الرئيسي للتعارض:
// useSelector يُعيد الكومبوننت عند كل تغير
// useEffect يُراقب تغيّرات، فإذا كانت مرتبطة بنفس القيمة اللي تتغير من dispatch
// 🔁 يصير تكرار أو تنفيذ غير متوقع

// ✅ الحلول المقترحة:
// الحالة	الحل المناسب
// تريد تنفيذ عند التحميل فقط	useEffect(() => { ... }, [])
// تريد تنفيذ عند شرط معين	useEffect(() => { if (x) {...} }, [x])
// تريد منع التكرار أو الحلقات	لا تعتمد على useSelector كتريغر مباشر

// ⚠️ خطأ شائع:
// jsx
// نسخ
// تحرير
// useEffect(() => {
//   dispatch(fetchUser());
// }, [user]); // ❌ غلط: لأنه مرتبط بشيء يتغير من نفس الـ dispatch
// هل تحب أعمل لك مثال عملي فيه useSelector + useEffect بطريقة سليمة؟








// أنت قلت:
// طيب وايش مشكلة انو انا بدي استخدم البيانات وهي لسا ما بكون واصلة في اليوزسيليكتور ؟ 


// قال ChatGPT:
// ممتاز يا أحمد، هذا واحد من أكثر الأسئلة المهمة في التعامل مع Redux و useSelector 👇

// 🧠 أولًا: نفهم كيف يشتغل كل واحد
// ✅ useSelector:
// يُستخدم لقراءة قيمة من الـ Redux store.

// أي تغيير في القيمة في الـ store → يجعل الكومبوننت يعيد render.

// هو reactive: يعني يراقب التغير تلقائيًا.

// ✅ useEffect:
// يُستخدم لتشغيل كود بعد كل render حسب تغيّرات محددة (dependencies).


// فبيصير بيناتهم مشكلة : 
// -------------  1
// انو بيصير تكرار تنفيذ بشكل غير متوقع 
const user = useSelector((state) => state.auth.user);

useEffect(() => {
  dispatch(fetchUser());
}, [user]);

// ❌ هنا يحصل خطأ منطقي:

// fetchUser() يقوم بتحديث user في الـ Redux.

// هذا يجعل user يتغير ➤ يعيد تنفيذ useEffect.

// يعيد dispatch(fetchUser()) ➤ ويعيد user التحديث...

// 🔁 🔁 🔁 حلقة لا نهائية أو تنفيذ متكرر.

//  الحل:
// ضع trigger منفصل أو استدعِه مرة وحدة:

// useEffect(() => {
//   dispatch(fetchUser());
// }, []); // ✅ فقط عند أول مرة



// -------------  2
// الخطا الثاني انك بتحاول تستخدمه قبل ما يوصل من الستور 
// undefined أو null أو {}
// فبيعطيك هذا الايرور 
// TypeError: Cannot read properties of undefined (reading 'name')

// الحل هكذا : 
// لازم تستخدم الثلاث حلول
// 1 - {user?.name && <p>مرحبا، {user.name}</p>} التحقق قبل الاستخدام
// 2- استخدام الللودينج في عرض حالة التحميل

// if (loading) {
//   return <p>جاري التحميل...</p>;
// }

// 3 - استخدام useEffect لتحميل البيانات أول مرة:
useEffect(() => {
  if (!user) {
    dispatch(fetchUser());
  }
}, []);
// 4 : استخدمها مباشرة  مع مراعاة الشروط السابقة react states  تخزنش البيانات في 
// مثال : مهم جداا جداا
// const array = Array.isArray(anyarray_here) ? anyarray_here.map() : []


// 🔁 الحل النهائي:
// ❗️ لا تتعامل مع user.name أو أي بيانات حساسة إلا بعد ما تتأكد إنها موجودة
// 🔒 استخدم الشرط: user && user.name أو user?.name

// مش معرف بعدين بيصير ديسباتش من خلال يوزايفيكت هاذا اليوزايفيكت بيحدث الستيت وتحديث الستيت بيخلي اليوزسيليكتور يعمل ريريندر عشان يحدث البيانات  null , undefined الفكرة انو بيعمل اول حاجة جلب لبيانات من اليوزسيليكتور فبيكون 
// يعني في المرة الاولى كان undefined لكن في المرة الثانية كان في بيانات حقيقة
// لذلك احنا عشان هيك نبعمل تشيك للمرة الاولى انو مثلا يعطي مصفوفة فاضية يخلي القيمة صفر وهكذا

// ================================================================================
// ================================================================================
// ================================================================================
// ================================================================================
// ================================================================================

// هلقيت زي ما حكينا كيف تعمل متابعة للفانكشن الغير متزامنة بطريقتين 
//  1- باستخدام البروميس 
//      .then()
//      .catch()
//      ex : dispatch().unwrap().then().catcb()

//  2- الطريقة الثانية باستخدام 
//      async function name(){
//         try(
//             await + unwrap
//         )catch(err){
//         }
//      }

// الطريقة الثانية هي الحديثة وهي الافضل 
// uesEffecy  لكن في ملاحظة مع 
// ما بتقدر تستخدم async فبنستخدم الطريقة الاولى 
// اما باقي الفانكشن عالطريقة الثانية